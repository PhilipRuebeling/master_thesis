# -*- coding: utf-8 -*-
"""photonic_devices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cc8FqOwkjEFPuOJC3iq5tUpCk6g2s5sp

$$\newcommand{\ket}[1]{\left|{#1}\right\rangle}\newcommand{\bra}[1]{\left\langle
{#1}\right|}$$
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install pyswarms
# %pip install fst-pso

import numpy as np
import fstpso as fp

"""# Quantum Frequency Processor (QFP) with coherent states

We can use coherent states to operate our QFP. This can be easily achieved by noting, that for a coherent state $\ket{\alpha} = D(\alpha)\ket{vac}$, where the displacement operator is defined by $D(\alpha) = \exp (\sum_{r} \alpha_{r} a^{\dagger}_{r} + \alpha_{r}^{*} a_{r})$. When we consider the mode transformation

$a^{\dagger}_{r} \rightarrow Sa^{\dagger}_{r}S^{\dagger} = \sum_{q} (-ie^{-i\vartheta})^{q} J_{q}(m)a^{\dagger}_{r+q}$.

parameters of the QFP
"""

n_layers, n_bins = 4, 32  # parameters of the QFP

def unitaryV(parameters_ps, parameters_em) :
    V = np.eye(bins, dtype='complex64')
    for layer in range(0, n_layers) :
        U_em = em.unitaryFD(parameters_em[layer], mod_depth, n_bins)
        U_ps = ps.unitaryFD(parameters_ps[layer], n_bins)
        V = V @ U_ps @ U_eom
    return V



def optimize_circuit_fuzzypso() :
  FP = fp.FuzzyPSO()
  search_space = fp.setupSearchSpace(a_min, a_max)
  FP.set_search_space(search_space)
  FP.set_fitness(costfunction)  
  FP.set_swarm_size(swarm_size)
  best_solution, fitness = FP.solve_with_fstpso(max_iter=iterations)
  return best_solution, fitness

"""# Electro-optic modulator (EOM)

The phase modulation of an [EOM](https://en.wikipedia.org/wiki/Electro-optic_modulator) is described by its driving voltage

$a(t) = \sum_{k=1}^{m} a_{k}\sin(\Omega_{k} t + \varphi_{k})$

Here we call $m = 1, 2, \dots$ the modulation depth. When we concentrate on single-tone modulation we will set this to be equal to $1$.
"""

import scipy.special

mod_depth = 1     # modulation depth
a_min = 00.00     # minimal modulation amplitude
a_max = 10.00     # maximal modulation amplitude

"""This defines the unitary in time domain (TD)."""

def unitaryTD(parameters, mod_depth, n_bins) :
    U = np.zeros(shape=(n_bins, n_bins), dtype="complex64")
    amplitude, phase = parameters
    for i in range(0, d):
        U[i][i] += np.exp(1j*(amplitude*np.sin(np.pi*i/d + phase)))
    return U

"""Here is the corresponding unitary in frequency domain (FD)."""

def unitaryFD(parameters, mod_depth, n_bins) :
    F = dft(bins)/np.sqrt(bins)
    U = unitaryTD(parameters, mod_depth, d) #doesn't involve yet.
    return F @ U @ RT.adjoint(F)

"""todo"""

def besselFD(parameters, n_bins, f=0.42) :
    U = np.zeros(shape=(d,d), dtype='complex64')
    amplitude, phase = parameters
    for i in range(0, d) :
        for j in range(0, d) :
            if(np.abs(i-j) <= math.ceil(amplitude+2)) :
                U[i][j] = special.jv(i-j, f*amplitude)*(-1j*np.exp(-1j*phase))**(i-j)
    return U

"""# phase shaper (PS)"""

